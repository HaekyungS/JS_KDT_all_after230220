<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <div id="root"></div>
  <script>
    let pokemon = ["삐카츄","라이츄","파이리","꼬북이","잠만보","리자몽","메타몽","에비츄"];
    let root = document.getElementById('root');
    
    // for(
      //   let index = 0; //숫자 0을 index라는 변수에 담았다.
      //   index < 10; // 만약 index가 10보다 작다면 (비교연산)
      //   index = index + 1 //이 연산을 해줘. 연산은 index+1을 index에 담아줘
      //   ) { };
         //이게 for문의 원형. 위 비교연산을 통해 컴퓨터한테 반복횟수를 제한시킬 수 있음. 그 제어를 위해 마지막 연산처럼 인덱스를 증가시켜줌. 안그러면 무한루프.
         //위처럼 하는 일도 절차. 일일히 절차를 알려주는 중임
         // 위와 같은 명령문을 명령형 프로그래밍 = 절차형 프로그래밍 이라 함.
      
      for(i=0;i<pokemon.length;i++){
        let li = document.createElement("li");
        li.textContent = pokemon[i];
        root.appendChild(li);
       //이렇게 자바로 li태그를 만들어낸거임. 동적으로 문서를 만들었다 함.
      }//이렇게 내가 길이를 몰라도 length라는 길이가 얼만큼 변해도 반복문을 이용하여 길이만큼 로그를 찍을 수 있음.
      //pokemon[0]-> pokemon[i] 로 하고 싶다면 술어로 말할 땐 pokemon에 리터럴을 걷어내라 혹은 0을 i라는 변수로 바꿔라~


    // console.dir(root)
    
    // console.dir(pokemon);
    // console.log(pokemon[4]);//리터럴로 잠만보찾기
    // console.log(pokemon[pokemon.length-1]);
    // console.log(pokemon.length);
    // //배열의 마지막요소를 찾으려던 것인데 리터럴을 사용하게되면 배열의 요소가 증가했을 때 자동으로 찾지 못함. 그래서 두번째꺼처럼 하면 배열의 요소가 아무리 증가해도 배열의 마지막자리를 찾을 것임.
    
    // let root = window["document"].getElementById('root');
    // //원형은 window부터가 맞는데 매번 쓰기 귀찮으니 알아서 써줘서 우리는 document부터 쓰는 것뿐. DOM API의 최상위객체는 window 이다.
    // let a = window
    // console.dir(a)
    </script>
</body>
</html>